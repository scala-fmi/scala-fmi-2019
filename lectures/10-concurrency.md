---
title: Конкурентност
---
# Досега?

::: incremental

* Програми с мощността на ламбда смятането/машината на Тюринг
* Последователни изчисления, не се влияят от времето
* Нямат връзка с околния свят
* вход =&gt; предвидима трансформация =&gt; изход
* Трансформиращи програми
* Добре изучени

:::

# IO

```scala
import Console._

val program = for {
  _     <- putStrLn("What is your name?")
  name  <- getStrLn
  _     <- putStrLn("Hello, " + name + ", welcome!")
} yield ()

program.unsafeRun()

doSomethingElse()
```

::: incremental

* Връзка с външния свят
* Но синхронна – програмата не прави нищо друго докато чака
* Интерактивни програми

:::

# Реалният свят

::: incremental

* Светът навън е силно паралелен и конкурентен
* Нещо повече, участниците в него си взаимодействат
* Развива се във времето
* Как да моделираме такива програми?

:::

# Конкурентност и паралелизъм


<div class="align">
  <dl class="fragment">
    <dt>parallel</dt>
    <dd>from παρά + ἄλληλος, along each other</dd>
  </dl>
  
  <dl class="fragment">
    <dt>concurrent</dt>
    <dd>present active participle of concurrō (“happen at the same time with”), from con- (“with”) + currō (“run”)</dd>
  </dl>
  
  <dl class="fragment">
    <dt>concurrent computing</dt>
    <dd>a form of computing in which several computations are executed during overlapping time periods—concurrently—instead of sequentially</dd>
  </dl>
</div>

# Дистрибутираност

<p class="fragment">Независими компоненти със собствени изчислителни ресурси и памет, които комуникират помежду си чрез съобщения и изграждат цялостна система</p>

# Реактивност

<p class="fragment">Свойството на програмите/компонентите да реагират<br />на света около тях<span class="fragment"> (с което да са част от него)</span></p>

# Конкурентност

В изчислителен контекст:

::: incremental
 
* _конкурентността_ се отнася към структурата на програмата,
* _паралелизмът_, _дистрибутираността_ – към хардуера и как тя ще бъде изпълнявана.

:::

<p class=fragment>Конкурентните програми са композитност от unit-и от изчисления, които, веднъж дефинирани, могат да бъдат изпълнени независимо едно от друго.</p>

# Конкурентни модели

* Нишки
* I/O и TCP/IP конкурентност
* Callbacks
* Event loop
* Future и Promise
* Конкурентни опашки
* Агенти
* Актьорски модел
* Communicating Sequential Processes
* Software Transactional Memory
* Stream/dataflow конкурентност
* ...

# Какво прави един модел подходящ?

::: incremental

* Лесен за проследяване и за разсъждаване върху твърдения за него
* Предоставя изразни средства, с които да решим проблемът, който моделираме<span class="fragment">, но ни предпазва от сложността на по-общи проблеми</span>
* Не скрива особеностите на света на проблема<span class="fragment"> – недетерминизъм, възможност за грешки, латентност и други</span>
* Предпазва ни от състояния, до които не искаме да стигаме, ако не са в домейна на проблема<span class="fragment"> – race conditions, недетерминизъм и други</span>
* Композитен
* Минимизира недетерминистичното влияние на времето
* Functional programming to the rescue

:::

# Нишки

# Комуникация между конкурентни примитиви

::: incremental

* За да бъде смислен, всеки конкурентен примитив е нужно да има поне една интеракция с околния свят или с други примитиви
* Границите с дистрибутираните системи се размиват
* Нишки – чрез споделена памет и средства на процесора и ОС

:::

# Happens-before

::: incremental

* Запис във `volatile` променлива __се случва преди__ последващо нейно прочитане (от същата или друга нишка).
* За всеки два последователни statement-а в една нишка, първият __се случва преди__ вторият.
* Релацията е транзитивно затворена.
* Happens-before образува частична наредба.
* Стартирането на нишка __се случва преди__ всеки statement от стартираната нишка.

:::

# Happens-before

JVM ни гарантира, че всяка референция към immutable обект сочи към обект с напълно валидно състояние.

<p class="fragment">Затова неизменямостта улеснява reasoning-а значително и премахва огромен клас от възможни грешки при конкурентни програми.</p>

# Проблеми на нишките

# Какво прави един модел подходящ?

* Лесен за проследяване и за разсъждаване върху твърдения за него
* Предоставя изразни средства, с които да решим проблемът, който моделираме, но ни предпазва от сложността на по-общи проблеми
* Не скрива особеностите на света на проблема – недетерминизъм, възможност за грешки, латентност и други
* Предпазва ни от състояния, до които не искаме да стигаме, ако не са в домейна на проблема – race conditions, недетерминизъм и други
* Композитен
* Минимизира недетерминистичното влияние на времето

# Проблеми на нишките

::: incremental

* Тежки – всяка има стек, регистри, превключването е бавно и минава през ядрото на ОС, стартират бавно
* Трудни за проследяване – недетерминизъм е възможен във всяка една част, споделяща данни с други нишки 
* Фин контрол на недетерминизма – чрез мютекси и други средства за синхронизация (race conditions, deadlocks)
* Некомпозитни, не поддържат трансформации
* Всяка последваща задача трябва да бъде създадена императивно от самата нишка
* Синхронност срещу асинхронност
* [The Problem with Threads](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2006/EECS-2006-1.pdf)

:::

#

Конкурентните програми са композитност от изчислителни примитиви (unit-и), които, веднъж дефинирани, могат да бъдат изпълнени независимо едно от друго

# Конкурентни изчислителни примитиви

::: incremental

* Колко да са големи, колко дълго да живеят?
* Как други примитиви могат да реагират на тяхното завършване или на тяхно действие (реактивност)?
* Как да си говорят едни с други?
* Как да се композират?

:::

# Нишките

::: incremental

* Липсва реактивност
  * но могат активно да създадат други нишки
  * и да променят споделено състояние
* Комуникират
  * чрез споделено състояние
  * чрез синхронни и блокиращи операции<span class="fragment"> – докато операцията не завърши нишката не може да прави нищо друго</span>
* Не се композират

:::

# Callbacks?


```scala
def doSomething(onComplete: Result => Unit): Unit
```

::: incremental

* Асинхронни и реактивни
* Задействат се при завършване на работа или при определено събитие <span class="fragment">(естествени за event loop)</span>
* Ще ги изпълним върху pool от нишки (брой = ~брой ядра)

:::

<div class="fragment">

```scala
def doSomethingDangerous(onComplete: Try[Result] => Unit): Unit
```

</div>

# Callbacks – негативи

::: incremental

* Императивни, работят с mutable state
* Некомпозитни. Callback hell
* Ако се изпълняват в различни нишки, изискват синхронизация
* Ръчно спряване с грешки

:::

# Future

Какво бяхме постигнали с `IO`?

::: incremental

* Страничен ефект =&gt; функционален ефект
* Който можем да третираме като стойност
* Функционално композиране на ефекти (по определена операция)
* Странични ефекти само при изпълнение

:::

#

Да създадем `Future`

# Изрази

```scala
val a = 42
val b = 4

val c = a + b
val d = (a + b) * 10
val e = f(g(a))

```

# Императивнo срещу функционалнo

::: incremental

* Императивните програми
  * описват постъпкови промени във времето
  * всяка стъпка зависи от всички предишни
  * всяка нишка е императивна програма със собствена времева линия
  * споделената памет води до преплитане на много времеви линии
* Функционалните програми
  * са изградени от изрази
  * изразите описват зависимости<span class="fragment">. По декларативен начин</span>
  * резултатът на един израз зависи от неговите операнди, но самите операнди за независими
  * те могат да се изчислят паралелно
  * композиция на изрази/функции описва зависимост. Тя се изчислява последователно
  * редът на изразите няма значение. В какъвто и ред да се изпълнят, стига да се спазят зависимостите, ще се получи един и същи резултат

:::

# Eager vs lazy

::: incremental

* `Future` се изчислява асинхронно =&gt; допустимо е да се изчисляват eagerly
* т.е. изчислението да започне веднага след дефинирането и когато станат готови всички зависимости
* Ще разгледаме и двата варианта

:::

# Реактивност на `Future`

::: incremental

* `Future` комуникира с други `Future`-и
  * при стартиране (стартира когато неговите зависимости са готови)
  * и при завършване ("уведомява" зависимите от него)
* Как да го вържем с други източници на събития?
* Promise
* Promise-ите ще генерират първоначални Future-и в нашата система
* Адаптер към външния свят, например позволяват реактивност към събития за вход/изход
* Ще ги скриваме за функционален интерфейс

:::

# `Future` в Scala

* `scala.concurrent.Future`
* Използва `ExecutionContext` вместо `Executor`

# Съществуваща стойност към `Future`

```scala
Future.successful(value)
```

# Recover

```scala
(for {
  user <- retrieveUser(userId)
  result <- doService(user, input)
} yield Ok(constructBody(result))) recover {
  case UserNotFound(userId) => NotFound
  case _: ActionNotPermitted => Unauthorized
}
```

# Recover with друга, по-стабилна алтернатива

```scala
def calculate(input: ServiceInput): Future[Result] = {
  dangerousService(input).recoverWith {
    case _: ServiceFailure => safeService(input)
  }
}
```

# Състезание

```scala
def algorithm1(input: String): Future[Int] = ???
def algorithm2(input: String): Future[Int] = ???

def calculation(input: Stirng): Future[Int] =
  Future.firstCompletedOf(List(algorithm1(input), algorithm2(input)))

```

# Неопределен брой независими изчисления

```scala
def averageFriendsAge(user: User): Future[Option[Int]] = for {
  friendIds: List[Id] <- user.friends
  ages: Future[List[Int]] <- Future.sequence(friendIds.map(retrieveAge): List[Future[Int]])
} yield average(ages)
```

# Асинхронност срещу синхронност

::: incremental

* И двете имат и ползи и недостатъци
* Подходящи за различни случаи
* Асинхронността позволява конкурентните примитиви да продължат работа с нещо друго
  * Позволява гъвкавост, код, описващ зависимости и лесно паралелизиране
  * За разлика от синхронността, не създава строга зависимост между два компонента
  * По-точно описва физическия свят
  * По-лесно за програмиране при възможност за грешки
* Синхронността кара синхронните примитиви да изчакват резултат
  * По-лесно за проследяване
  * Изисква допълнителни ресурси, но при подходяща имплементация носи гарантиран throughput (например чрез синхронен clock)

:::

# Асинхронен вход/изход чрез `Future`

* HTTP client
* HTTP server

# Task – lazy Future

Ще разгледаме `Task` имплементацията на [Monix](https://monix.io/docs/2x/eval/task.html)

# Task - създаване

* Task.now (= Future.successful)
* Task.eval(async computation) / Task { async computation }
* Task.evalOnce
* Task.deferFuture

# Task – композиране

* Task.zip2,...,  Task.zipN
* Task.zipMap2,...,  Task.zipMapN
* map, flatMap
* Task.sequence
* Task.chooseFirstOfList(List(a, b))

# Task – изпълнение

::: incremental

* `val result: Future[Int] = Task(1 + 1).runAsync`
* ```scala
  Task(1 + 1).runOnComplete {
    case Success(value) => ???
    case Failure(e) => ???
  }
   ```
* `Task(1 + 1).foreach(???)`
* Нуждае се от `monix.execution.Scheduler` – подобно на ExecutionContext

:::

# Task

* Подобно на IO, първо описаме план от трансформации
* Като всеки план, може да се изпълнява множество пъти 

# Актьорски модел

::: incremental

* Математически модел за конкурентни процеси, представен от Carl Hewitt през 1973
* Актьорите са универсиални изчислителни примитиви
* Те комуникират помежду си чрез съобщения
* Erlang независимо имплементирар този модел през 80-те

:::

# Актьори

::: incremental

* Всеки актьор изпълнява функционална/Тюринг програма
* Всеки актьор си има адрес, на който могат да бъдат изпращани съобщения
* Програмата се нарича "поведение" и се задейства при получаване на съобщение
* Изходът от поведението, задействано от съобщението, съдържа:
  * Поведението, което ще бъде изпълнено при следващото съобщение
  * Списък от актьори, които да бъдат създадени, и начално поведение за тях
  * Списък от съобщения и съответни адреси на получатели, които да бъдат изпратени
  
:::

# Актьори – недетерминизъм

::: incremental

* Поведението на актьора е детерминирано
* Всичко останало моделира недетерминизма на физическия свят. Съобщенията:
  * могат да бъдат изгубени – няма гаранция, че ще стигнат до получателя
  * могат да пристигнат в произволен ред
  * пристигат след неопределено време

:::

# Актьорите като конкурентен примитив

* Комуникацията със съобщения е напълно асинхронна
* Те са реактивни от гледна точка на получаването на съобщения
* Трудно композитни са
* За сметка на по-реалистично моделиране на физическия свят
* Не споделят памет и не се нуждаят от средства за синхронизация. Всичко се оркестрира чрез комуникацията със съобщенията