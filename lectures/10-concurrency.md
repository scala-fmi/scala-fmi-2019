---
title: Конкурентност
---
# Досега?

::: incremental

* Програми с мощността на ламбда смятането/машината на Тюринг
* Последователни изчисления, не се влияят от времето
* Нямат връзка с околния свят
* вход =&gt; предвидима трансформация =&gt; изход
* Трансформиращи програми
* Добре изучени

:::

# IO

```scala
import Console._

val program = for {
  _     <- putStrLn("What is your name?")
  name  <- getStrLn
  _     <- putStrLn("Hello, " + name + ", welcome!")
} yield ()

program.unsafeRun()

doSomethingElse()
```

::: incremental

* Връзка с външния свят
* Но синхронна – програмата не прави нищо друго докато чака
* Интерактивни програми

:::

# Реалният свят

::: incremental

* Светът навън е силно паралелен и конкурентен
* Нещо повече, участниците в него си взаимодействат
* Развива се във времето
* Как да моделираме такива програми?

:::

# Конкурентност и паралелизъм


<div class="align">
  <dl class="fragment">
    <dt>parallel</dt>
    <dd>from παρά + ἄλληλος, along each other</dd>
  </dl>
  
  <dl class="fragment">
    <dt>concurrent</dt>
    <dd>present active participle of concurrō (“happen at the same time with”), from con- (“with”) + currō (“run”)</dd>
  </dl>
  
  <dl class="fragment">
    <dt>concurrent computing</dt>
    <dd>a form of computing in which several computations are executed during overlapping time periods—concurrently—instead of sequentially</dd>
  </dl>
</div>

# Дистрибутираност

<p class="fragment">Независими компоненти със собствени изчислителни ресурси и памет, които комуникират помежду си чрез съобщения и изграждат цялостна система</p>

# Реактивност

<p class="fragment">Свойството на програмите/компонентите да реагират<br />на света около тях<span class="fragment"> (с което да са част от него)</span></p>

# Конкурентност

В изчислителен контекст:

::: incremental
 
* _конкурентността_ се отнася към структурата на програмата,
* _паралелизмът_, _дистрибутираността_ – към хардуера и как тя ще бъде изпълнявана.

:::

<p class=fragment>Конкурентните програми са композитност от unit-и от изчисления, които, веднъж дефинирани, могат да бъдат изпълнени независимо едно от друго.</p>

# Конкурентни модели

* Нишки
* I/O и TCP/IP конкурентност
* Callbacks
* Event loop
* Future и Promise
* Конкурентни опашки
* Агенти
* Актьорски модел
* Communicating Sequential Processes
* Software Transactional Memory
* Stream/dataflow конкурентност
* ...

# Какво прави един модел подходящ?

::: incremental

* Лесен за проследяване и за разсъждаване върху твърдения за него
* Предоставя изразни средства, с които да решим проблемът, който моделираме<span class="fragment">, но ни предпазва от сложността на по-общи проблеми</span>
* Не скрива особеностите на света на проблема<span class="fragment"> – недетерминизъм, възможност за грешки, латентност и други</span>
* Предпазва ни от състояния, до които не искаме да стигаме, ако не са в домейна на проблема<span class="fragment"> – race conditions, недетерминизъм и други</span>
* Композитен
* Минимизира недетерминистичното влияние на времето
* Functional programming to the rescue

:::

# Нишки

# Комуникация между конкурентни примитиви

::: incremental

* За да бъде смислен, всеки конкурентен примитив е нужно да има поне една интеракция с околния свят или с други примитиви
* Границите с дистрибутираните системи се размиват
* Нишки – чрез споделена памет и средства на процесора и ОС

:::

# Happens-before

::: incremental

* Запис във `volatile` променлива __се случва преди__ последващо нейно прочитане (от същата или друга нишка).
* За всеки два последователни statement-а в една нишка, първият __се случва преди__ вторият.
* Релацията е транзитивно затворена.
* Happens-before образува частична наредба.
* Стартирането на нишка __се случва преди__ всеки statement от стартираната нишка.

:::

# Happens-before

JVM ни гарантира, че всяка референция към immutable обект сочи към обект с напълно валидно състояние.

<p class="fragment">Затова неизменямостта улеснява reasoning-а значително и премахва огромен клас от възможни грешки при конкурентни програми.</p>

# Проблеми на нишките

# Какво прави един модел подходящ?

* Лесен за проследяване и за разсъждаване върху твърдения за него
* Предоставя изразни средства, с които да решим проблемът, който моделираме, но ни предпазва от сложността на по-общи проблеми
* Не скрива особеностите на света на проблема – недетерминизъм, възможност за грешки, латентност и други
* Предпазва ни от състояния, до които не искаме да стигаме, ако не са в домейна на проблема – race conditions, недетерминизъм и други
* Композитен
* Минимизира недетерминистичното влияние на времето

# Проблеми на нишките

::: incremental

* Тежки – всяка има стек, регистри, превключването е бавно и минава през ядрото на ОС
* Трудни за проследяване – недетерминизъм е възможен във всяка една част, обхващаща споделени данни
* Фин контрол на недетерминизма – чрез мютекси и други средства за синхронизация (race conditions, deadlocks)
* Некомпозитни, не поддържат трансформации
* Всяка последваща задача трябва да бъде създадена императивно от самата нишка
* Синхронност срещу асинхронност
* [The Problem with Threads](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2006/EECS-2006-1.pdf)

:::

# Callbacks?

# Future

Какво бяхме постигнали с `IO`?

::: incremental

* Страничен ефект =&gt; функционален ефект
* Функционално композиране на ефекти (по определена операция)
* Странични ефекти само при изпълнение

:::

# Как ни помага функционалното програмиране?

* Immutability
* Работа върху детерминистични snapshot-и от миналото
* Композитност
* Предвидимост 

