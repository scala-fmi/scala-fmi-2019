# Функционално програмиране за напреднали със Scala

## Лекции

* [01 – За курса](https://scala-fmi.github.io/scala-fmi-2019/lectures/01-intro.html) \[[примерен код](lectures/examples/01-intro)\]
  - Кратка история на функционалното програмиране
  - Защо Scala?
  - Scala като SCAlable LAnguage. Примерен код
  - Инсталиране и инструменти
  - Hello World
  - Тестове
* [02 – Въведение в езика Scala](https://scala-fmi.github.io/scala-fmi-2019/lectures/02-scala-intro.html) \[[код](lectures/02-scala-intro-code.txt)\]
  - Принципи на Scala
  - Примитивни и основни типове. Литерали
  - Дефиниции – `val`, `var`, `def`. Типове и type inference
  - Функции
  - Йеархия на типовете
  - `Null`, `Nothing`, `Unit`
  - Контролни структури – `if`, `while`, `for`. Генератори, филтри и дефиниции. Контролните структури и блоковете като изрази
  - Основни операции върху `List`, `String`, `Range`
* [03 – Обектно ориентирано програмиране за отчаяни](https://scala-fmi.github.io/scala-fmi-2019/lectures/03-oop.html) \[[код](lectures/examples/03-oop/)\]
  - Номинално срещу Структурно типизиране
  - ООП primer
  - Classes
  - Object и Companion Objects
  - Uniform Access Principle
  - Case classes
  - Traits
  - Дискусия за ООП + ФП
* [04 – Основи на функционалното програмиране](https://scala-fmi.github.io/scala-fmi-2019/lectures/04-functional-programming-basics.html) \[[код](lectures/04-functional-programming-basics-code.txt)\]
  - Функции в математическия смисъл
  - Референтна прозрачност (referential transparancy)
  - Модел на изчисление чрез заместване (substitution model)
  - Функциите като първокласни обекти
  - Рекурсия, опашкова рекурсия
  - Неизменяемост
  - Персистентни структури от данни (`List`, `Vector`, ...)
  - Функционален тип, функционални литерали (ламбда функции)
  - Композиция на функции
  - Функции от по-висок ред - `map`, `filter`, `foldLeft` и други
* [05 – Currying, наредени n-торки, колекции](https://scala-fmi.github.io/scala-fmi-2019/lectures/05-currying-tuples-collections.html) \[[код](lectures/05-currying-tuples-collections.txt)\]
  - Currying
  - `fold` и операции чрез `fold`
  - Използване на типовете от определена сигнатура като изразно средство и за насоки за имплементация (примери 1)
  - Наредени n-торки
  - Връщане на множество резултати чрез n-торки
  - Import – включване на елементи от други именовани пространства – пакети и обекти
  - Частични функции
  - Колекции – `List`, `Map`, `Set`, `Array`
  – Някои общи операции върху колекции – `map`, `filter`, `foldLeft`, `forall`, `exists`, `groupBy`, `zip`, `partition`, `splitAt` и други 
  - Йеархия на колекциите
  - Изменяеми и неизменяеми колекции
  – `flatten`, `flatMap` и връзка с `for`
* 06 – Съпоставяне по образци и алгебрични типове от данни (ADTs) \[[код](lectures/06-pattern-matching-and-adts.txt)\]
  - Съпоставяне по образци (pattern matching) и деструктуриране чрез `match`
  - Съпоставяне по образци/деструктуриране при дефиниране на променлива (при `val`, `var` или `for`)
  - Частични функции. Синтаксис за частични функции чрез съпоставяне по образци
  - Алгебра. Алгебрични типове от данни (algebraic data types)
  - Продуктови типове (product types)
  - Сумиращи типове (sum types)
  - Комплексност на типове
  - Проблеми с `null`
  - Опционалност и `Option`. Трансформации върху `Option`
  - Елиминиране на нелегалните състояния чрез ограничаване на възможността за тяхното представяне
  - Имплементация на деструктуриране за тип, extractor-и – `unapply`. Примери с `Email` и `Regex`
  - Използване на типовете от определена сигнатура като изразно средство и за насоки за имплементация (примери 2)
* 07 – Ефекти и функционална обработка на грешки \[[код](lectures/07-effects-and-functional-error-handling.txt)\]
  - Комплексност на функции
  - Ефекти
  - Видове ефекти – частичност, изключения/грешки, недетерминизъм, зависимости/конфигурация, логване, изменяемо състояние, вход/изход, асинхронност, и други. Типове зад тях
  - `type` дефиници
  - `Option`, `Try`. Проблеми с изключенията
  - `Either`. Моделиране на грешки
  - Комбиниране на ефекти
  - IO ефект за вход/изход. Предимства
  - Разделение на чисто функционално композитно изграждане на план (без странични ефекти) от изпълнение на плана (водещо до странични ефекти)
  - Ковариантност и контравариантност на типове
  - Ковариантни и контравариантни ограничения на типовете при използването им
* [08 – Implicits](https://scala-fmi.github.io/scala-fmi-2019/lectures/08-implicits.html)
* 09 – Laziness
  - Стриктно и нестриктно изчисление \[[код](lectures/09-LazyEval.txt)\]
  - Потоци (Streams) \[[код](lectures/09-Streems.txt)\]
* [10 – Конкурентно програмиране](https://scala-fmi.github.io/scala-fmi-2019/lectures/10-concurrency.html) \[[код](lectures/examples/10-concurrency)\]
  - Трансформиращи, интерактивни и реактивни програми
  - Характеристики на физическия свят
  - Цел: моделиране на програми, които да са част от физическия свят и да взаимодействат с него
  - Конкурентност и паралелилизъм – припрокритие и разлики на термините
  - Дистрибутираност и реактивност
  - Примери за конкурентни модели
  - Какво прави един модел подходящ? Примерни характеристики
  - Нужда от комуникация между конкурентни примитиви
  - Нишки, happens-before релация върху JVM, проблеми на нишките
  - Callback функции. Ползи и проблеми
  - Future – ефект за асинхронност
  - Моделиране на Future, следвайки ползите и принципите на IO
  - Функционалното програмиране като съвкупност от изрази. Декларативност на изразите. Еднозначно определяне на зависимостите чрез изрази, дърво от зависимости (дърво на израз). Пренасяне на свойствата на изразите върху ефектните операции
  - Eager и lazy Future-и
  - Реализация на Eager Future. Future и Promise. Примерно използване
  - Реактивност на Future
  - Future в Scala. `ExecutionContext`
  - Помощни функции при работа с Future за чести сценарии
  - Сравнение между асинхронност и синхронност
  - Асинхронни HTTP client и HTTP server чрез Future
  - Lazy Future. Примери чрез `Task` от библиотеката Monix
  - (опционално, непокрито на лекцията: ) Актьорски модел. Прости примери. Актьорите като конкурентен примитив
* [11 – Type classes](https://scala-fmi.github.io/scala-fmi-2019/lectures/11-type-classes.html) \[[код](lectures/examples/11-type-classes)\]
  - Абстрактност като помощно средство в програмирането и абстрактност в математиката
  - Какво е type class. Пример чрез моноид
  - Контекст в програмния код. Контекстност на type class-овете в Scala
  - Context bound
  - Защо спазването на аксиомите е важно. Разлика между `fold` и `foldLeft`
  - Сравнение между ООП класовете и type class-овете
  - Полиморфизъм и видове полиморфизъм
  - Други type class-ове – `Numeric`, `Ordering`, (опционално, непокрито на лекцията: ) типове за информация чрез `ClassTag` и `TypeTag` 
  - Type class-ове за преформатиране, пример за JSON сериализация
  - Логически изводи при търсене на implicit стойности, логическа типова система
  - `Monoid` и `Semigroup` в библиотеката Cats
  - Multiversal срещу universal equality, `Eq` в Cats
  - Пример за type class-ове на повече типове, линейно пространство в Spire
* [12 Монади и функтори](https://scala-fmi.github.io/scala-fmi-2019/lectures/12-monads-and-functors.html) \[[код към лекцията](lectures/examples/12-monads-and-functors/lecture-code)\] \[[примерен код с квадратни уравнения](lectures/examples/12-monads-and-functors/monad-examples)\]
  - Ефекти. Абстракция над общите операции на ефекти
  - Композиране на функции. Аксиоми
  - Ефектни функции
  - Монада – type class за композиране на ефектни функции
  – Дефиниция на монада чрез compose и unit. Аксиоми
  - Дефиниция чрез flatMap и unit. Аксиоми
  - Производни операции на монади. `map`, `flatten`, `zip`, `map2`, `sequence` и други. Алтернативни дефиници
  - Реализация на type class за монада, с помощни операции
  - Монадни инстанции на основни ефектни типове
  – Реализация на Maybe (алтернативно име на Option), монадна инстанция към Maybe и пример за работа с получените монадни операции
  - [State монада](lectures/examples/12-monads-and-functors/state-monad.md)
  - Функтори като генерализация на монадите
  – Имплементации на функтор и монада в Cats
  - Композитност на функтори
  – Композитност на монади, описани на случаи, в които се композират, и в които не
  – Нули на монади
  – Примери за програма, решаваща квадрано уравнение

## Build-ване

### Setup

Имате нужда от инсталиран [pandoc](https://pandoc.org/installing.html).

Проектът има submodule зависимост към reveal.js. При/след клониране на репото инициализирайте модулите:

    git submodule update --init

### Генериране на лекция

    cd lectures
    ./generate-presentation.sh <лекция>

### Генериране на всички лекции

    cd lectures
    ./build.sh

### Стартиране на REPLesent script

Свалете пакета REPLesent от https://github.com/marconilanna/REPLesent и го настройте според инструкциите.

Сложете script файловете (*.txt) в директорията на REPLesent и след като го стартирате, изпълнете в конзолата командите:

    val replesent = REPLesent(source="02-scala-intro-code.txt",intp=$intp)
    import replesent._

като използвате подходящия файл за съответния script.
